Title: Android Game Loop
Author: Ken Ko
Date: 2013-09-23
Tags: coding, android, game
Category: tutorials

The Android/Eclipse code can be found [here](https://github.com/ko/breakout-island/tree/v0.1).

I've been meaning to take a look at a simple game loop under Android. 
What we essentially want is similar to the Arduino environment's
setup() and loop() calls. Under an Arduino process, code will
be constantly executed under the main loop(). Similarly, we want to
have the game loop to effectively be:

<pre>
<code>
while(running) {
    update_game_state();
    render_graphics();
}
</code>
</pre>

However there will be some boilerplate, so let's set that up. The
following will be 3 files: 

1. MainActivity.java
2. MainThread.java
3. MainPanel.java

The MainActivity's purpose is simply to run the MainPanel.
The MainPanel is the main game panel/screen which will also execute
the MainThread (containing the game loop) in the background.

The main work involved in the MainActivity is simply setting up
the MainPanel SurfaceView to be displayed. Note that the 
R.layout.activity_main is *not* deflated here.

<pre>
<code>
    @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            Log.d(TAG, "Requesting no title");
            requestWindowFeature(Window.FEATURE_NO_TITLE);

            Log.d(TAG, "Setting full screen");
            getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, 
                    WindowManager.LayoutParams.FLAG_FULLSCREEN);

            Log.d(TAG, "Setting content view");
            setContentView(new MainPanel(this));

            Log.d(TAG, "Main game panel view added");
        }
</code>
</pre>

The MainPanel is probably the most complex of the three pieces,
for now. Here we have code for both starting the MainThread thread
as well as exiting the MainThread thread. So, the MainPanel is
in charge of starting/stopping the game loop's execution.

<pre>
<code>
    public MainPanel(Context context) {
        super(context);
        getHolder().addCallback(this);

        // instantiate game loop thread
        thread = new MainThread(getHolder(), this);

        setFocusable(true);
    }
    
    ...

    @Override
    public void surfaceDestroyed(SurfaceHolder arg0) {
        boolean retry = true;
        while (retry) {
            try {
                thread.join();
                retry = false;
            } catch (InterruptedException e) {
                // try again
            }
        }
    }

    ...

    @Override
    public boolean onTouchEvent(MotionEvent event) {

        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            if (event.getY() < 50) {
                /* stop game loop if touching the top 50 pixels of the screen */
                thread.setRunning(false);
                ((Activity)getContext()).finish();
            } else {
                Log.d(TAG, "Coords(x,y)=(" + event.getX() + "," + event.getY() + ")");
            }
        }

        return super.onTouchEvent(event);
    }
</code>
</pre>

Also note that the MainPanel has code to detect touch events so that
we may stop the MainThread (or game loop) if we touch the top 50 pixels
of the screen. 

The MainThread holds our simple game loop.

<pre>
<code>
    /** game loop */
    @Override
    public void run() {
        long ticks = 0L;
        Log.d(TAG, "Starting game loop");
        while (running) {
            ticks++;

            //updateGameState();
            //renderGameState();
        }
        Log.d(TAG, "Game loop ran " + ticks + "times");
    }
</code>
</pre>

Hope that helps. The rest of the code is superfluous (for now) or 
consists of autogenerated code.
